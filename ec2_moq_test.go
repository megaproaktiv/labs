// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package labdeploy

import (
	"context"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	"sync"
)

// Ensure, that Ec2InterfaceMock does implement Ec2Interface.
// If this is not the case, regenerate this file with moq.
var _ Ec2Interface = &Ec2InterfaceMock{}

// Ec2InterfaceMock is a mock implementation of Ec2Interface.
//
//     func TestSomethingThatUsesEc2Interface(t *testing.T) {
//
//         // make and configure a mocked Ec2Interface
//         mockedEc2Interface := &Ec2InterfaceMock{
//             CreateKeyPairFunc: func(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error) {
// 	               panic("mock out the CreateKeyPair method")
//             },
//             DeleteKeyPairFunc: func(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error) {
// 	               panic("mock out the DeleteKeyPair method")
//             },
//             DescribeImagesFunc: func(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error) {
// 	               panic("mock out the DescribeImages method")
//             },
//             DescribeKeyPairsFunc: func(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error) {
// 	               panic("mock out the DescribeKeyPairs method")
//             },
//         }
//
//         // use mockedEc2Interface in code that requires Ec2Interface
//         // and then make assertions.
//
//     }
type Ec2InterfaceMock struct {
	// CreateKeyPairFunc mocks the CreateKeyPair method.
	CreateKeyPairFunc func(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error)

	// DeleteKeyPairFunc mocks the DeleteKeyPair method.
	DeleteKeyPairFunc func(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error)

	// DescribeImagesFunc mocks the DescribeImages method.
	DescribeImagesFunc func(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error)

	// DescribeKeyPairsFunc mocks the DescribeKeyPairs method.
	DescribeKeyPairsFunc func(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateKeyPair holds details about calls to the CreateKeyPair method.
		CreateKeyPair []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *ec2.CreateKeyPairInput
			// OptFns is the optFns argument value.
			OptFns []func(*ec2.Options)
		}
		// DeleteKeyPair holds details about calls to the DeleteKeyPair method.
		DeleteKeyPair []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *ec2.DeleteKeyPairInput
			// OptFns is the optFns argument value.
			OptFns []func(*ec2.Options)
		}
		// DescribeImages holds details about calls to the DescribeImages method.
		DescribeImages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *ec2.DescribeImagesInput
			// OptFns is the optFns argument value.
			OptFns []func(*ec2.Options)
		}
		// DescribeKeyPairs holds details about calls to the DescribeKeyPairs method.
		DescribeKeyPairs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *ec2.DescribeKeyPairsInput
			// OptFns is the optFns argument value.
			OptFns []func(*ec2.Options)
		}
	}
	lockCreateKeyPair    sync.RWMutex
	lockDeleteKeyPair    sync.RWMutex
	lockDescribeImages   sync.RWMutex
	lockDescribeKeyPairs sync.RWMutex
}

// CreateKeyPair calls CreateKeyPairFunc.
func (mock *Ec2InterfaceMock) CreateKeyPair(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error) {
	if mock.CreateKeyPairFunc == nil {
		panic("Ec2InterfaceMock.CreateKeyPairFunc: method is nil but Ec2Interface.CreateKeyPair was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params *ec2.CreateKeyPairInput
		OptFns []func(*ec2.Options)
	}{
		Ctx:    ctx,
		Params: params,
		OptFns: optFns,
	}
	mock.lockCreateKeyPair.Lock()
	mock.calls.CreateKeyPair = append(mock.calls.CreateKeyPair, callInfo)
	mock.lockCreateKeyPair.Unlock()
	return mock.CreateKeyPairFunc(ctx, params, optFns...)
}

// CreateKeyPairCalls gets all the calls that were made to CreateKeyPair.
// Check the length with:
//     len(mockedEc2Interface.CreateKeyPairCalls())
func (mock *Ec2InterfaceMock) CreateKeyPairCalls() []struct {
	Ctx    context.Context
	Params *ec2.CreateKeyPairInput
	OptFns []func(*ec2.Options)
} {
	var calls []struct {
		Ctx    context.Context
		Params *ec2.CreateKeyPairInput
		OptFns []func(*ec2.Options)
	}
	mock.lockCreateKeyPair.RLock()
	calls = mock.calls.CreateKeyPair
	mock.lockCreateKeyPair.RUnlock()
	return calls
}

// DeleteKeyPair calls DeleteKeyPairFunc.
func (mock *Ec2InterfaceMock) DeleteKeyPair(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error) {
	if mock.DeleteKeyPairFunc == nil {
		panic("Ec2InterfaceMock.DeleteKeyPairFunc: method is nil but Ec2Interface.DeleteKeyPair was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params *ec2.DeleteKeyPairInput
		OptFns []func(*ec2.Options)
	}{
		Ctx:    ctx,
		Params: params,
		OptFns: optFns,
	}
	mock.lockDeleteKeyPair.Lock()
	mock.calls.DeleteKeyPair = append(mock.calls.DeleteKeyPair, callInfo)
	mock.lockDeleteKeyPair.Unlock()
	return mock.DeleteKeyPairFunc(ctx, params, optFns...)
}

// DeleteKeyPairCalls gets all the calls that were made to DeleteKeyPair.
// Check the length with:
//     len(mockedEc2Interface.DeleteKeyPairCalls())
func (mock *Ec2InterfaceMock) DeleteKeyPairCalls() []struct {
	Ctx    context.Context
	Params *ec2.DeleteKeyPairInput
	OptFns []func(*ec2.Options)
} {
	var calls []struct {
		Ctx    context.Context
		Params *ec2.DeleteKeyPairInput
		OptFns []func(*ec2.Options)
	}
	mock.lockDeleteKeyPair.RLock()
	calls = mock.calls.DeleteKeyPair
	mock.lockDeleteKeyPair.RUnlock()
	return calls
}

// DescribeImages calls DescribeImagesFunc.
func (mock *Ec2InterfaceMock) DescribeImages(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error) {
	if mock.DescribeImagesFunc == nil {
		panic("Ec2InterfaceMock.DescribeImagesFunc: method is nil but Ec2Interface.DescribeImages was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params *ec2.DescribeImagesInput
		OptFns []func(*ec2.Options)
	}{
		Ctx:    ctx,
		Params: params,
		OptFns: optFns,
	}
	mock.lockDescribeImages.Lock()
	mock.calls.DescribeImages = append(mock.calls.DescribeImages, callInfo)
	mock.lockDescribeImages.Unlock()
	return mock.DescribeImagesFunc(ctx, params, optFns...)
}

// DescribeImagesCalls gets all the calls that were made to DescribeImages.
// Check the length with:
//     len(mockedEc2Interface.DescribeImagesCalls())
func (mock *Ec2InterfaceMock) DescribeImagesCalls() []struct {
	Ctx    context.Context
	Params *ec2.DescribeImagesInput
	OptFns []func(*ec2.Options)
} {
	var calls []struct {
		Ctx    context.Context
		Params *ec2.DescribeImagesInput
		OptFns []func(*ec2.Options)
	}
	mock.lockDescribeImages.RLock()
	calls = mock.calls.DescribeImages
	mock.lockDescribeImages.RUnlock()
	return calls
}

// DescribeKeyPairs calls DescribeKeyPairsFunc.
func (mock *Ec2InterfaceMock) DescribeKeyPairs(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error) {
	if mock.DescribeKeyPairsFunc == nil {
		panic("Ec2InterfaceMock.DescribeKeyPairsFunc: method is nil but Ec2Interface.DescribeKeyPairs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params *ec2.DescribeKeyPairsInput
		OptFns []func(*ec2.Options)
	}{
		Ctx:    ctx,
		Params: params,
		OptFns: optFns,
	}
	mock.lockDescribeKeyPairs.Lock()
	mock.calls.DescribeKeyPairs = append(mock.calls.DescribeKeyPairs, callInfo)
	mock.lockDescribeKeyPairs.Unlock()
	return mock.DescribeKeyPairsFunc(ctx, params, optFns...)
}

// DescribeKeyPairsCalls gets all the calls that were made to DescribeKeyPairs.
// Check the length with:
//     len(mockedEc2Interface.DescribeKeyPairsCalls())
func (mock *Ec2InterfaceMock) DescribeKeyPairsCalls() []struct {
	Ctx    context.Context
	Params *ec2.DescribeKeyPairsInput
	OptFns []func(*ec2.Options)
} {
	var calls []struct {
		Ctx    context.Context
		Params *ec2.DescribeKeyPairsInput
		OptFns []func(*ec2.Options)
	}
	mock.lockDescribeKeyPairs.RLock()
	calls = mock.calls.DescribeKeyPairs
	mock.lockDescribeKeyPairs.RUnlock()
	return calls
}
